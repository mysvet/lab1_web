# Импортируем необходимые библиотеки
from PIL import Image, ImageDraw  # Для работы с изображениями
import numpy as np  # Для преобразования изображений в массивы и работы с ними
import matplotlib

matplotlib.use('Agg')  # Используем "безголовый" бэкенд Matplotlib
import matplotlib.pyplot as plt  # Для построения гистограмм

# Повторный импорт для совместимости
from PIL import Image, ImageDraw


def draw_cross(input_path, output_path, orientation, color):
    """
    Рисует "настоящий" крест на изображении:
    - Вертикальный крест: длинная вертикальная линия (на всю высоту изображения) +
                          короткая горизонтальная (примерно 1/3 ширины, по центру)
    - Горизонтальный крест: длинная горизонтальная линия (на всю ширину) +
                            короткая вертикальная (примерно 1/3 высоты, по центру)

    Параметры:
        input_path (str): путь к исходному изображению
        output_path (str): путь для сохранения изображения с крестом
        orientation (str): ориентация креста — 'vertical' или 'horizontal'
        color (tuple): цвет креста в формате RGB, например (255, 0, 0) для красного
    """
    # Открываем изображение и конвертируем его в RGB
    img = Image.open(input_path).convert('RGB')
    # Создаём объект для рисования на изображении
    draw = ImageDraw.Draw(img)
    # Получаем ширину и высоту изображения
    w, h = img.size

    # Определяем толщину линий креста: 2% от наименьшей стороны изображения, но не менее 1 пикселя
    thickness = max(1, int(min(w, h) * 0.02))

    if orientation == 'vertical':
        # Рисуем вертикальный крест

        # Длинная вертикальная линия: проходит по центру изображения сверху донизу
        x1 = w // 2 - thickness // 2  # левая граница линии
        x2 = x1 + thickness  # правая граница линии
        # Рисуем прямоугольник (вертикальную полосу) от верхнего края (y=0) до нижнего (y=h)
        draw.rectangle([x1, 0, x2, h], fill=color)

        # Короткая горизонтальная линия: длина = 1/3 ширины изображения, расположена по центру по вертикали
        short_w = w // 3  # длина короткой горизонтальной линии
        y1 = h // 2 - thickness // 2  # верхняя граница линии
        y2 = y1 + thickness  # нижняя граница линии
        hx1 = (w - short_w) // 2  # левая граница короткой горизонтальной линии (по центру)
        hx2 = hx1 + short_w  # правая граница
        draw.rectangle([hx1, y1, hx2, y2], fill=color)

    else:  # orientation == 'horizontal'
        # Рисуем горизонтальный крест

        # Длинная горизонтальная линия: проходит по центру изображения слева направо
        y1 = h // 2 - thickness // 2  # верхняя граница линии
        y2 = y1 + thickness  # нижняя граница линии
        # Рисуем прямоугольник (горизонтальную полосу) от левого края (x=0) до правого (x=w)
        draw.rectangle([0, y1, w, y2], fill=color)

        # Короткая вертикальная линия: длина = 1/3 высоты изображения, расположена по центру по горизонтали
        short_h = h // 3  # длина короткой вертикальной линии
        x1 = w // 2 - thickness // 2  # левая граница линии
        x2 = x1 + thickness  # правая граница линии
        vy1 = (h - short_h) // 2  # верхняя граница короткой вертикальной линии (по центру по высоте)
        vy2 = vy1 + short_h  # нижняя граница
        draw.rectangle([x1, vy1, x2, vy2], fill=color)

    # Сохраняем изображение с нарисованным крестом
    img.save(output_path)


def plot_histograms(orig_path, proc_path, hist_orig_path, hist_proc_path):
    """
    Строит и сохраняет гистограммы распределения цветов (R, G, B) для двух изображений:
    - исходного
    - обработанного (с наложенным крестом)

    Параметры:
        orig_path (str): путь к исходному изображению
        proc_path (str): путь к изображению с крестом
        hist_orig_path (str): путь (без расширения) для сохранения гистограммы исходного изображения
        hist_proc_path (str): путь (без расширения) для сохранения гистограммы обработанного изображения
    """

    def get_hist(img_path):
        """
        Вспомогательная функция: загружает изображение и возвращает плоские массивы значений
        для каждого цветового канала (R, G, B).
        """
        img = np.array(Image.open(img_path).convert('RGB'))  # Преобразуем в массив NumPy
        r = img[:, :, 0]  # Красный канал
        g = img[:, :, 1]  # Зелёный канал
        b = img[:, :, 2]  # Синий канал
        # Возвращаем "сплющенные" (одномерные) массивы
        return r.flatten(), g.flatten(), b.flatten()

    # --- Гистограмма для исходного изображения ---
    plt.figure(figsize=(6, 3))  # Устанавливаем размер графика
    r, g, b = get_hist(orig_path)
    # Накладываем гистограммы для каждого канала с прозрачностью
    plt.hist(r, bins=256, color='red', alpha=0.5, label='R')
    plt.hist(g, bins=256, color='green', alpha=0.5, label='G')
    plt.hist(b, bins=256, color='blue', alpha=0.5, label='B')
    plt.title('Исходное')  # Заголовок
    plt.legend()  # Легенда (R, G, B)
    plt.tight_layout()  # Автоматическая подгонка элементов
    plt.savefig(hist_orig_path + '.png')  # Сохраняем в файл
    plt.close()  # Закрываем фигуру, чтобы не расходовать память

    # Гистограмма для обработанного изображения
    plt.figure(figsize=(6, 3))
    r, g, b = get_hist(proc_path)
    plt.hist(r, bins=256, color='red', alpha=0.5)
    plt.hist(g, bins=256, color='green', alpha=0.5)
    plt.hist(b, bins=256, color='blue', alpha=0.5)
    plt.title('После наложения креста')
    plt.tight_layout()
    plt.savefig(hist_proc_path + '.png')
    plt.close()